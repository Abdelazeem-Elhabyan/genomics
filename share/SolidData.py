#     SolidData.py: module for handling data about SOLiD sequencer runs
#     Copyright (C) University of Manchester 2011 Peter Briggs
#
########################################################################
#
# SolidData.py
#
#########################################################################

"""SolidData

Provides classes for extracting data about SOLiD runs from directory
structure, data files and naming conventions.

Typical usage is to create a new SolidRun instance by pointing it at
the top-level output directory produced by the sequencer:

>>> solid_run = SolidRun('/path/to/solid0123_20141225_FRAG_BC')

This will automatically attempt to collect the data about the run, which
can then be accessed via other objects linked through the SolidRun
object's properties.

The most useful are:

SolidRun.run_info: a SolidRunInfo object which holds data extracted
  from the run name (e.g. instrument, datestamp etc)

SolidRun.samples: a list of SolidSample objects which hold data about
  each of the samples in the run.

Each sample in turn holds a list of libraries within that sample
(SolidLibrary objects in 'SolidSample.libraries') and a list of projects
(SolidProject objects in 'SolidSample.projects'). The 'getLibrary' and
'getProject' methods also provide ways to look up specific libraries
or projects.

Projects are groupings of libraries (based on library names) which are
assumed to form a single experiment. The libraries within a project can
be obtained via the SolidLibrary.projects, or using the 'getLibrary'
method.

Finally, SolidLibrary objects hold data about the location of the
primary data files. The 'SolidLibrary.csfasta' and 'SolidLibrary.qual'
properties hold the locations of the data for the F3 reads, while for
paired-end runs the 'SolidLibrary.csfasta_f5' and 'SolidLibrary.qual_f5'
properties point to the F5 reads.

(The 'is_paired_end' function can be used to test whether a SolidRun
object holds data for a paired-end run.)
"""

#######################################################################
# Import modules that this module depends on
#######################################################################

import sys,os
import string
import logging

#######################################################################
# Class definitions
#######################################################################

class SolidRun:
    """Describe a SOLiD run.

    The SolidRun class provides an interface to data about a SOLiD
    run. It analyses the SOLiD data directory to look for run
    definitions, statistics files and primary data files.

    It uses the same terminology as the SETS interface and the data
    files produced by the SOLiD instrument, so a run contains
    'samples' and each sample contains one or more 'libraries'.

    One initialised, access the data about the run via the SolidRun
    object's properties:

    run_dir: directory with the run data
    run_name: name of the run e.g. solid0123_20130426_FRAG_BC
    run_info: a SolidRunInfo object with data derived from the run name
    run_definition: a SolidRunDefinition object with data extracted from
      the run_definition.txt file
    samples: a list of SolidSample objects representing the samples in
      the run
    """

    def __init__(self,solid_run_dir):
        """Create and populate a new SolidRun instance.

        Arguments:
          solid_run_dir: path to the top-level directory holding the files
          generated by the SOLiD sequencer run e.g.
          /path/to/SOLiD/data/solid0123_20130426_FRAG_BC
        """

        # Initialise
        self.run_dir = None
        self.run_name = None
        self.run_info = None
        self.run_definition = None
        self.samples = []

        # Basic data the supplied directory name
        if not os.path.isdir(os.path.abspath(solid_run_dir)):
            # Directory not found
            logging.info("SOLiD data dir '%s' not found" % solid_run_dir)
            return

        self.run_dir = os.path.abspath(solid_run_dir)
        self.run_name = self.run_dir.strip(os.sep).split(os.sep)[-1]
        self.run_info = SolidRunInfo(self.run_name)

        # Locate and process the run definition file
        self.run_defn_filn = os.path.join(self.run_dir,
                                          self.run_name+"_run_definition.txt")
        if os.path.isfile(self.run_defn_filn):
            self.run_definition = SolidRunDefinition(self.run_defn_filn)
        else:
            # Unable to find run definition
            logging.error("Unable to find run definition file for %s" % self.run_dir)
            return

        # Determine samples and libraries
        for i in range(0,self.run_definition.nSamples()):
            sample_name = self.run_definition.getDataItem('sampleName',i)
            library_name = self.run_definition.getDataItem('library',i)

            # Barcoded samples
            #
            # Look for content in the "barcodes" column for the library
            # in the run definition file
            #
            # There may be several barcoded samples
            # Example barcode items:
            # --> "1"
            # --> "1,2,3,4,5,6,7,8"
            # (or could be empty)
            try:
                barcodes = self.run_definition.getDataItem('barcodes',i)
            except IndexError:
                barcodes = ''
            logging.debug("%s: barcodes: %s" % (library_name,barcodes))
            library_is_barcoded = (barcodes != '' and barcodes)
            if library_is_barcoded:
                barcodes = barcodes.strip('"').split(',')

            # Look for the directory with the results
            #
            # There should be a symlink "results" that will
            # point to the actual results directory
            results = os.path.join(self.run_dir,sample_name,'results')
            if os.path.islink(results):
                libraries_dir = os.path.join(self.run_dir,
                                             sample_name,
                                             os.readlink(results),
                                             'libraries')
            else:
                libraries_dir = None

            if not sample_name in [s.name for s in self.samples]:
                # New sample
                sample = SolidSample(sample_name,parent_run=self)
                self.samples.append(sample)
                # Locate and process barcode statistics
                if libraries_dir:
                    for f in os.listdir(libraries_dir):
                        if f.startswith("BarcodeStatistics"):
                            barcode_stats_filn = os.path.join(libraries_dir,f)
                            sample.barcode_stats = \
                                SolidBarcodeStatistics(barcode_stats_filn)
                            break
                else:
                    logging.warning("Libraries directory '%s' is missing" % libraries_dir)
                    
            # Store the library
            library = sample.addLibrary(library_name)
            library.is_barcoded = library_is_barcoded

            # Locate data files for this library
            #
            # This is a bit convoluted but essentially we're
            # looking for a "primary.XXXXXXX" subdirectory of the
            # <library> subdirectory, which contains a "reject"
            # subdirectory
            # The "reads" subdirectory parallel to the "reject"
            # dir has the data we want
            #
            # For non-paired-end runs there should only be one
            # matching directory, containing data files with 'F3'
            # in the names.
            # For paired-end runs there should be two matching
            # directories, one with the 'F3' files and the other
            # with the 'F5' files.
            
            # Check for directory with result files
            if libraries_dir:
                this_library_dir = os.path.join(libraries_dir,library.name)
                if not os.path.isdir(this_library_dir):
                    this_library_dir = None
            else:
                this_library_dir = None

            # Locate the primary data
            got_primary_data = False
            got_primary_data_f5 = False
            ambiguity_error = False
            if this_library_dir:
                logging.debug("Library dir: %s..." % this_library_dir)
                # Iterate over available directories
                for d in os.listdir(this_library_dir):
                    logging.debug("--> Library %s subdir: %s" % (library_name,d))
                    reject = os.path.join(this_library_dir,d,"reject")
                    reads = os.path.join(this_library_dir,d,"reads")
                    reports = os.path.join(this_library_dir,d,"reports")
                    # Check that we have 'reject', 'reads' and 'reports'
                    if os.path.isdir(reject) and \
                            os.path.isdir(reads) and \
                            os.path.isdir(reports):
                        logging.debug("---> has all of reads, reject and reports")
                        # Check for csfasta and qual files
                        csfasta = None
                        qual = None
                        csfasta_f5 = None
                        qual_f5 = None
                        for f in os.listdir(reads):
                            ext = os.path.splitext(f)[1]
                            if ext == ".csfasta":
                                csfasta = os.path.abspath( \
                                    os.path.join(reads,f))
                            elif ext == ".qual":
                                qual = os.path.abspath( \
                                    os.path.join(reads,f))
                        # Check barcoded samples
                        if library.is_barcoded:
                            if csfasta:
                                if csfasta.rfind('_F5-BC_') > -1:
                                    # F5 reads
                                    csfasta_f5 = csfasta
                                if csfasta.rfind('_F3_') < 0:
                                    # Not a recognised name
                                    csfasta = None
                            if qual:
                                if qual.rfind('_F5-BC_') > -1:
                                    # F5 reads
                                    qual_f5 = qual
                                if qual.rfind('_F3_') < 0:
                                    qual = None
                        # Store primary data: F3 reads
                        if csfasta and qual:
                            if got_primary_data:
                                ambiguity_error = True
                                logging.warning("Located F3 primary data in multiple locations:\n"
                                                "\t%s\n\t%s\nand\n\t%s\n\t%s",
                                                library.csfasta,library.qual,
                                                csfasta,qual)
                                # Resolve by storing the most recent
                                if (os.path.getmtime(csfasta) > 
                                    os.path.getmtime(library.csfasta)) \
                                    and (os.path.getmtime(qual) > 
                                         os.path.getmtime(library.qual)):
                                    library.csfasta = csfasta
                                    library.qual = qual
                            else:
                                library.csfasta = csfasta
                                library.qual = qual
                                got_primary_data = True
                                logging.debug("-----> Located primary data (F3)")
                        # Store primary data: F5 reads
                        if csfasta_f5 and qual_f5:
                            if got_primary_data_f5:
                                # More than one candidate for primary data
                                ambiguity_error = True
                                logging.warning("Located F5 primary data in multiple locations:\n"
                                                "\t%s\n\t%s\nand\n\t%s\n\t%s",
                                                library.csfasta_f5,
                                                library.qual_f5,
                                                csfasta_f5,qual_f5)
                                # Resolve by storing the most recent
                                if (os.path.getmtime(csfasta_f5) > 
                                    os.path.getmtime(library.csfasta_f5)) \
                                    and (os.path.getmtime(qual_f5) > 
                                         os.path.getmtime(library.qual_f5)):
                                    library.csfasta_f5 = csfasta_f5
                                    library.qual_f5 = qual_f5
                            else:
                                library.csfasta_f5 = csfasta_f5
                                library.qual_f5 = qual_f5
                                got_primary_data_f5 = True
                                logging.debug("-----> Located primary data (F5)")

            if not got_primary_data:
                logging.warning("Unable to locate some or all primary data for %s" % library)
            elif ambiguity_error:
                logging.warning("Ambigiuous location for some primary data for %s" % library)

    def fetchLibraries(self,sample_name='*',library_name='*'):
        """Retrieve libraries based on sample and library names

        Supplied names can be exact matches or simple patterns (using trailing
        '*'s as wildcards). '*' matches all names.

        Arguments:
          sample_name: (optional) a name or pattern to match against sample
            names (matches all sample names if not specified)
          library_name: (optional) a name or pattern to match against
            library names (matches all library names if not specified)

        Returns:
          A list of SolidLibrary objects which match the supplied sample and
          library names or patterns.
        """
        matching_libraries = []
        for sample in self.samples:
            if match(sample_name,sample.name):
                # Found a matching sample
                for library in sample.libraries:
                    if match(library_name,library.name):
                        # Found a matching library
                        logging.debug("Located sample and library: %s/%s" %
                                      (sample.name,library.name))
                        matching_libraries.append(library)
        if len(matching_libraries) == 0:
            logging.debug("No libraries matched to %s/%s in %s" % (sample_name,library_name,
                                                                   self.run_dir))
        # Finished
        return matching_libraries

    def slideLayout(self):
        """Return description of the slide layout

        Returns:
          A string describing the slide layout for the run based on
          the number of samples in the run, e.g. "Whole slide", "Quads",
          "Octets" etc.
          Returns None if the slide layout can't be determined.
        """
        return slide_layout(len(self.samples))

    def __nonzero__(self):
        """Implement nonzero built-in

        SolidRun object is False if the source directory doesn't
        exist, or if basic data couldn't be loaded."""
        if not self.run_name:
            return False
        elif not self.run_info:
            return False
        elif not self.run_definition:
            return False
        else:
            return True

class SolidSample:
    """Store information about a sample in a SOLiD run.

    A sample has a name and contains a set of libraries.
    The information about the sample can be accessed via the
    following properties:

    name: the sample name
    libraries: a list of SolidLibrary objects representing the libraries
      within the sample
    projects: a list of SolidProject objects representing groups of
      related libraries within the sample
    barcode_stats: a SolidBarcodeStats object with data extracted from
      the BarcodeStatistics file (or None, if no file was available)
    parent_run: the parent SolidRun object, or None.

    The class also provides the following methods:

    addLibrary: to create and append a SolidLibrary object
    getLibrary: fetch an existing SolidLibrary
    getProject: fetch an existing SolidProject

    Typically the calling subprogram calls the 'addLibrary' method to
    add a SolidLibrary object, which it then populates itself.

    The SolidSample class automatically creates SolidProject objects
    based on the library names to group libraries considered to belong
    to the same experiments.
    """

    def __init__(self,name,parent_run=None):
        """Create a new SolidSample instance.

        Arguments:
          name: name of the sample (e.g. AS_XC_pool)
          parent_run: (optional) the parent SolidRun object
        """
        self.name = name
        self.libraries = []
        self.libraries_dir = None
        self.barcode_stats = None
        self.projects = []
        self.parent_run = parent_run

    def __repr__(self):
        """Implement __repr__ built-in

        Return string representation for the SolidSample -
        i.e. the sample name."""
        return str(self.name)

    def addLibrary(self,library_name):
        """Associate a library with the sample

        The supplied library is added to the list of libraries
        associated with the sample, if it's not already in the
        list.

        Arguments:
          library_name: name of the library to add

        Returns:
          New or existing SolidLibrary object representing the
          library.
        """
        # Check if the library is already in the list
        library = self.getLibrary(library_name)
        if not library:
            # Create new library object and add to list
            library = SolidLibrary(library_name,parent_sample=self)
            self.libraries.append(library)
            # Keep libraries in order
            self.libraries = sorted(self.libraries,
                                    key=lambda l: (l.prefix,l.index))
        # Deal with projects
        project_name = library.initials
        project = self.getProject(project_name)
        if not project:
            # Create new project
            project = SolidProject(project_name)
            self.projects.append(project)
        # Add the library to the project
        project.addLibrary(library)
        # Return library object
        return library

    def getLibrary(self,library_name):
        """Look up library object matching a library name

        Arguments:
          library_name: name of library to look up

        Returns:
          SolidLibrary object with the same name as 'library_name',
          or None if no names match.
        """
        for library in self.libraries:
            if library.name == library_name:
                return library
        # Not found 
        return None

    def getProject(self,project_name):
        """Look up project object matching a project name

        Arguments:
          project_name: name of the project to look up

        Returns:
          SolidProject object with the same name as 'project_name',
          or None if no names match.
        """
        for project in self.projects:
            if project.name == project_name:
                return project
        # Not found
        return None

class SolidLibrary:
    """Store information about a SOLiD library.

    The following properties hold data about the library:

    name: the library name
    initials: the experimenter's initials
    prefix: the library name prefix (i.e. name without the trailing
      numbers)
    index_as_string: the trailing numbers from the name, as a string
      (preserves any leading zeroes)
    index: the trailing numbers from the name as an integer
    csfasta: full path to the csfasta file for the library (F3 reads)
    qual: full path to qual file for the library (F3 reads)
    csfasta_f5: full path to the F5 read (paired-end runs, otherwise
      will be None)
    qual_f5: full path to the F5 read (paired-end runs, otherwise will
      be None)
    parent_sample: parent SolidSample object, or None.
    """

    def __init__(self,name,parent_sample=None):
        """Create a new SolidLibrary instance.

        Inputs:
          name: name of the library (e.g. AS_07)
          parent_sample: (optional) parent SolidSample object
        """
        # Name
        self.name = str(name)
        # Name-based information
        self.initials = extract_initials(self.name)
        self.prefix = extract_prefix(self.name)
        self.index_as_string = extract_index(self.name)
        if self.index_as_string == '':
            self.index = None
        else:
            self.index = int(self.index_as_string.lstrip('0'))
        # Barcoding
        self.is_barcoded = False
        # Associated data files
        self.csfasta = None
        self.qual = None
        self.csfasta_f5 = None
        self.qual_f5 = None
        # Parent sample
        self.parent_sample = parent_sample

    def __repr__(self):
        """Implement __repr__ built-in

        Return string representation for the SolidLibrary -
        i.e. the library name."""
        return str(self.name)

class SolidProject:
    """Class to hold information about a SOLiD 'project'

    A SolidProject object holds a collection of libraries which
    together constitute a 'project'.

    The definition of a 'project' is quite loose in this context:
    essentially it's a grouping of libraries within a sample.
    Typically the grouping is by the initial letters of the library
    name e.g. DR for DR1, EP for EP_NCYC2669 - but this determination
    is made at the application level.

    Libraries are added to the project via the addLibrary method.
    Data about the project can be accessed via the following
    properties:

    name: the project name (supplied on object creation)
    libraries: a list of libraries in the project

    Also has the following methods:

    getSample(): returns the parent SolidSample
    getRun(): returns the parent SolidRun
    isBarcoded(): returns boolean indicating whether the libraries
      in the sample are barcoded
    """

    def __init__(self,name,run=None,sample=None):
        """Create a new SolidProject object.

        Arguments:
          name: the name of the project.
          run: (optional) the parent SolidRun for the project
          sample: (optional) the parent SolidSample for the project
        """
        self.name = name
        self.libraries = []

    def addLibrary(self,library):
        """Add a library to the project.

        Arguments:
          library: SolidLibrary object to add to the project
        """
        if not isinstance(library,SolidLibrary):
            raise TypeError, "addLibrary requires SolidLibrary instance"
        self.libraries.append(library)

    def getSample(self):
        """Return the parent sample for the project.

        Returns the parent SolidSample object, or None if no parent
        is defined.
        """
        if len(self.libraries):
            return self.libraries[0].parent_sample
        else:
            return None

    def getRun(self):
        """Return the parent run for the project.

        Returns the parent SolidRun object for the project, by
        looking up the run that the parent sample belongs to.
        Returns None if no parent sample is defined, or if the
        parent sample doesn't have a parent run.
        """
        parent_sample = self.getSample()
        if parent_sample:
            return parent_sample.parent_run
        else:
            return None

    def isBarcoded(self):
        """Return boolean indicating if the libraries are barcoded.

        If all libraries in the project are barcoded then return
        True, otherwise return False if at least one isn't barcoded
        (or if there are no libraries associated with the project).
        """
        # If any library is not barcoded, return False
        for library in self.libraries:
            if not library.is_barcoded:
                return False
        # Will be True as long as there's at least one library
        return len(self.libraries) > 0

    def getLibraryNamePattern(self):
        """Return wildcard pattern matching all library names in the project.

        Find the longest pattern which matches all the library names in
        the project. For example if the project contains four libraries
        PB1, PB2, PB3 and PB4 then return 'PB*'.

        If the project only contains one library then the pattern will be
        the single name without wildcard characters.
        """
        pattern = None
        for library in self.libraries:
            if pattern is None:
                pattern = library.name
            else:
                new_pattern = []
                for i in range(min(len(pattern),len(library.name))):
                    if pattern[i] != library.name[i]:
                        if len(new_pattern) < len(library.name):
                            new_pattern.append('*')
                        pattern = ''.join(new_pattern)
                        break
                    else:
                        new_pattern.append(pattern[i])
        return pattern

    def getProjectName(self):
        """Return a name for the project.

        Typically this is the same as the project name assigned when
        the project was created, unless the project essentially maps
        to an entire sample (i.e. all the libraries in the parent
        sample are also in the project) - then the project name is
        the sample name.
        """
        if len(self.getSample().libraries) == len(self.libraries):
            return self.getSample().name
        else:
            return self.name

    def prettyPrintLibraries(self):
        """Return a nicely formatted string describing the library names

        Wraps a call to 'pretty_print_libraries' function.
        """
        return pretty_print_libraries(self.libraries)

class SolidRunInfo:
    """Extract data about a run from the run name
        
    Run names are of the form 'solid0123_20130426_FRAG_BC_2'
    
    This class analyses the name and breaks it down into components
    that can be accessed as object properties, specifically:
    
    name: the supplied run name
    instrument: the instrument name e.g. solid0123
    datestamp: e.g. 20130426
    is_fragment_library: True or False
    is_barcoded_sample: True or False
    flow_cell: 1 or 2
    date: datestamp reformatted as DD/MM/YY
    id: the run name without any flow cell identifier
    """

    def __init__(self,run_name):
        """Create and initialise a new SolidRunInfo instance

        Arguments:
          run_name: the name of the run, e.g. solid0123_20130426_FRAG_BC_2.
            NB this is not a path to a run directory
        """
        # Initialise
        self.name = str(run_name)
        self.id = None
        self.instrument = None
        self.datestamp = None
        self.is_fragment_library = False
        self.is_barcoded_sample = False
        self.flow_cell = 1
        self.date = None
        #
        data = str(run_name).split('_')
        #
        # Basic info
        self.instrument = data[0]
        self.datestamp = data[1]
        #
        # Fragment library
        if 'FRAG' in data:
            self.is_fragment_library = True
        #
        # Barcoded sample
        if 'BC' in data:
            self.is_barcoded_sample = True
        #
        # Flow cell
        if data[-1] == '2':
            self.flow_cell = 2
        #
        # I.D.
        self.id = "%s_%s" % (self.instrument,
                             self.datestamp)
        if self.is_fragment_library:
            self.id += "_FRAG"
        if self.is_barcoded_sample:
            self.id += "_BC"
        #
        # Date
        if len(self.datestamp) == 8:
            self.date = "%s/%s/%s" % (self.datestamp[6:8],
                                      self.datestamp[4:6],
                                      self.datestamp[2:4])

    def __repr__(self):
        """Implement __repr__ built in for str etc

        Returns the orginal run name, which encodes all the
        information held in the object.
        """
        return self.name

class SolidRunDefinition:
    """Class to store data from a SOLiD run definition file

    Once the SolidRunDefinition object is populated from a run
    definition file, use the 'nSamples' method to find out how
    many 'samples' (actually sample/library pairs) are defined,
    and the 'fields' method to get a list of column headings for
    each.

    Data can be extracted for each sample using the 'getDataItem'
    method to look up the value for a particular field on a
    particular line, e.g.:

    >>> library = run_defn.getDataItem('library',0)

    The SolidRunDefinition object also has a number of attributes
    populated from the header of the run definition file,
    specifically:
    
    version, userId, runType, isMultiplexing, runName, runDesc,
    mask and protocol.

    The attributes are strings and can be accessed directly from
    the object, e.g.:

    >>> version = run_defn.version
    >>> isMultiplexing = run_defn.isMultiplexing
    """

    def __init__(self,run_definition_file):
        """Create a new SolidRunDefinition object.

        Arguments:
          run_definition_file: name of run definition file (including
            any leading path) from which to extract data
        """
        self.file = run_definition_file
        # Header attributes
        self.version = None
        self.userId = None
        self.runType = None
        self.isMultiplexing = None
        self.runName = None
        self.runDesc = None
        self.mask = None
        self.protocol = None
        # Data about specific samples/libraries
        self.header_fields = []
        self.data = []
        try:
            self.populate()
        except IOError, ex:
            logging.error("Failed to populate SolidRunDefinition: '%s'" % ex)

    def __nonzero__(self):
        """Implement the built-in __nonzero__ method"""
        return len(self.data) != 0

    def fields(self):
        """Return list of fields"""
        return self.header_fields

    def nSamples(self):
        """Return the number of samples"""
        return len(self.data)

    def getDataItem(self,field,i):
        """Return data item from specified row

        Arguments:
          field: one of the fields read in from the file
          i: integer row index.

        Returns:
          Value stored for 'field' in row 'i'. Returns None
          if the field isn't found, and raises an IndexError
          exception if the index doesn't address an existing
          row."""
        try:
            pos = self.header_fields.index(field)
        except ValueError:
            logging.error("Field '%s' not found in '%s'" % (field,self.file))
            return None
        return self.data[i][pos]

    def populate(self):
        """Populate the SolidRunDefiniton object.

        Internal: loads data from the run definition file into
        the object."""
        # Initialise
        reading_header = False
        reading_samples = False
        # Open the file
        f = open(self.file,'r')
        for line in f:
            # Look for the header line (first line of the file) describing run attributes
            # This looks like:
            # version	userId	runType	isMultiplexing	runName	runDesc	mask	protocol
            if line.startswith("version"):
                reading_header = True
            elif reading_header:
                # Store the data from the header
                data = line.strip().split('\t')
                self.version = data[0]
                self.userId = data[1]
                self.runType = data[2]
                self.isMultiplexing = data[3]
                self.runName = data[4]
                self.runDesc = data[5]
                self.mask = data[6]
                self.protocol = data[7]
                reading_header = False
            # Look for header line for sample/library data
            # This looks like:
            # sampleName	sampleDesc	spotAssignments	primarySetting	library	application	secondaryAnalysis	multiplexingSeries	barcodes
            if line.startswith("sampleName"):
                for field in line.strip().split('\t'):
                    self.header_fields.append(field)
                reading_samples = True
            elif reading_samples:
                # Deal with information under the header
                data = line.strip().split('\t')
                self.data.append(data)
        # Finished
        f.close()

class SolidBarcodeStatistics:
    """Store data from a SOLiD BarcodeStatistics file"""

    def __init__(self,barcode_statistics_file):
        """Create a new SolidBarcodeStatistics object"""
        self.file = barcode_statistics_file
        self.header = None
        self.data = []
        try:
            self.populate()
        except IOError, ex:
            logging.error("Failed to populate SolidBarcodeStatistics: '%s'" % ex)

    def __nonzero__(self):
        """Implement the __nonzero__ built-in"""
        return len(self.data) != 0

    def populate(self):
        """Populate the SolidBarcodeStatistics object.
        """
        got_header = False
        f = open(self.file,'r')
        for line in f:
            if got_header:
                data = line.strip().split('\t')
                self.data.append(data)
            elif line.startswith('##'):
                self.header = line.strip().strip('#').split('\t')
                got_header = True
        f.close()

    def header(self):
        """Return list of header fields"""
        return self.header

    def nRows(self):
        """Return the number of rows"""
        return len(self.data)

    def getDataByName(self,name):
        """Return a row of data matching 'name'
        """
        for data in self.data:
            if data[0] == name:
                return data
        return None

    def totalReads(self):
        """Return the total reads

        The total reads are calculated as the totals for all beads less the
        subtotal of unassigned reads.

        If the required data cannot be found from the barcode stats data then
        returns None.
        """
        unassigned_subtotals = None
        all_beads_totals = None
        for line in self.data:
            if line[0] == 'unassigned' and line[1] == 'Subtotals':
                # Look for unassigned subtotals
                logging.debug(">>> %s" % line)
                if unassigned_subtotals is not None:
                    logging.warning("Multiple unassigned subtotals found")
                try:
                    unassigned_subtotals = int(line[-1])
                except ValueError:
                    logging.error("Unassigned subtotal '%s' is not an integer" % line[-1])
            elif line[0] == 'All Beads' and line[1] == 'Totals':  
                # Look for total of all beads
                logging.debug(">>> %s" % line)              
                if all_beads_totals is not None:
                    logging.warning("Multiple all beads totals found")
                try:
                    all_beads_totals = int(line[-1])
                except ValueError:
                    logging.error("Unassigned subtotal '%s' is not an integer" % line[-1])
        # Work out the total reads
        if unassigned_subtotals is None or all_beads_totals is None:
            logging.error("Unable to acquire values for one or both of subtotals or totals")
            return None
        else:
            return all_beads_totals - unassigned_subtotals

#######################################################################
# Module Functions
#######################################################################

def is_paired_end(solid_run):
    """Determine if a SolidRun instance is a paired-end run

    Arguments:
      solid_run: a populated SolidRun instance

    Returns:
      True if this is a paired-end run, False otherwise.
    """
    return (solid_run.run_definition.runType == "PAIRED-END")

def extract_initials(library):
    """Return leading initials from the library name

    The experimenter's initials are the leading characters of the
    library name e.g. 'DR' for 'DR1', 'EP' for 'EP_NCYC2669', 'CW' for
    'CW_TI' etc

    Arguments:
      library: a SolidLibrary object

    Returns:
      The leading initials from the library name.
    """
    initials = []
    for c in str(library):
        if c.isalpha():
            initials.append(c)
        else:
            break
    return ''.join(initials)
        
def extract_prefix(library):
    """Return the library name prefix

    Arguments:
      library: a SolidLibrary object

    Returns:
      The prefix of the library name, consisting of the name with
      trailing numbers removed, e.g. 'LD_C' for 'LD_C1'
    """
    return str(library).rstrip(string.digits)

def extract_index(library):
    """Return the library name index

    Arguments:
      library: a SolidLibrary object

    Returns:
      The index from the library name, consisting of the trailing
      numbers from the name. It is returned as a string to preserve
      leading zeroes, e.g. '1' for 'LD_C1', '07' for 'DR07' etc
    """
    index = []
    chars = [c for c in str(library)]
    chars.reverse()
    for c in chars:
        if c.isdigit():
            index.append(c)
        else:
            break
    index.reverse()
    return ''.join(index)

def match(pattern,word):
    """Check if a word matches pattern

    Implements a very simple pattern matching algorithm, which allows
    only exact matches or glob-like strings (i.e. using a trailing '*'
    to indicate a wildcard).

    For example: 'ABC*' matches 'ABC', 'ABC1', 'ABCDEFG' etc, while
    'ABC' only matches itself.

    Arguments:
      pattern: simple glob-like pattern
      word: string to test against 'pattern'

    Returns:
      True if 'word' is a match to 'pattern', False otherwise.
    """
    if not pattern or pattern == '*':
        # No pattern/wildcard, matches everything
        return True
    # Only simple patterns considered for now
    if pattern.endswith('*'):
        # Match the start
        return word.startswith(pattern[:-1])
    else:
        # Match the whole word exactly
        return (word == pattern)

def slide_layout(nsamples):
    """Description of the slide layout based on number of samples

    Arguments:
      nsamples: number of samples in the run

    Returns:
      A string describing the slide layout for the run based on the
      number of samples in the run, e.g. "Whole slide", "Quads",
      "Octets" etc. Returns None if the number of samples doesn't
      map to a recognised layout.
    """
    if nsamples == 1:
        return "Whole slide"
    elif nsamples == 4:
        return "Quads"
    elif nsamples == 8:
        return "Octets"
    else:
        logging.warning("Undefined layout for '%s' samples" % nsamples)
        return None

def pretty_print_libraries(libraries):
    """Given a list of libraries, format for pretty printing.

    Arguments:
      libraries: a list of SolidLibrary objects

    Returns:
      String with a condensed description of the library
      names, for example:

      ['DR1', 'DR2', 'DR3', DR4'] -> 'DR1-4'
    """
    # Split each library name into prefix and numeric suffix
    libs = sorted(libraries, key=lambda l: (l.prefix,l.index))
    # Go through and group
    groups = []
    group = []
    last_index = None
    for lib in libs:
        # Check if this is next in sequence
        try:
            if lib.index == last_index+1:
                # Next in sequence
                group.append(lib)
                last_index = lib.index
                continue
        except TypeError:
            # One or both of the indexes was None
            pass
        # Current lib is not next in previous sequence
        # Tidy up and start new group
        if group:
            groups.append(group)
        group = [lib]
        last_index = lib.index
    # Capture last group
    if group:
        groups.append(group)
    # Pretty print
    out = []
    for group in groups:
        if len(group) == 1:
            # "group" of one
            out.append(group[0].name)
        else:
            # Group with at least two members
            out.append(group[0].name+"-"+group[-1].index_as_string)
    # Concatenate and return
    return ', '.join(out)

#######################################################################
# Tests
#######################################################################
import unittest
import tempfile
import shutil

class TestUtils:
    """Utilities to help with setting up/running tests etc

    Provides methods for creating mock SOLiD directory structure populated
    with example files.

    make_solid_dir: constructs a mock SOLiD run directory, including the
    run definition and barcode statistics files

    make_run_definition_file: constructs a mock run definition file

    make_run_definition_file_paired_end: constructs mock run definition file for
    a paired-end run

    make_barcode_statistics_file: constructs a mock barcode statistics file
    """

    def make_run_definition_file(self,filename=None):
        """Create example run definition file.

        If a name is explicitly specified then the file will be created
        with that name; otherwise a temporary file name will be generated.

        Returns the name for the run definition file.
        """
        run_definition_text = \
"""version	userId	runType	isMultiplexing	runName	runDesc	mask	protocol
v0.0	user	FRAGMENT	TRUE	solid0123_20130426_FRAG_BC_2		1_spot_mask_sf	SOLiD4 Multiplex
primerSet	baseLength
BC	5
F3	50
sampleName	sampleDesc	spotAssignments	primarySetting	library	application	secondaryAnalysis	multiplexingSeries	barcodes
AB_CD_EF_pool		1	default primary	CD_UV5	SingleTag	mm9	BC Kit Module 1-16	"7"
AB_CD_EF_pool		1	default primary	CD_PQ5	SingleTag	mm9	BC Kit Module 1-16	"6"
AB_CD_EF_pool		1	default primary	CD_ST4	SingleTag	mm9	BC Kit Module 1-16	"5"
AB_CD_EF_pool		1	default primary	EF11	SingleTag	dm5	BC Kit Module 1-16	"8"
AB_CD_EF_pool		1	default primary	EF12	SingleTag	dm5	BC Kit Module 1-16	"9"
AB_CD_EF_pool		1	default primary	EF13	SingleTag	dm5	BC Kit Module 1-16	"10"
AB_CD_EF_pool		1	default primary	EF14	SingleTag	dm5	BC Kit Module 1-16	"11"
AB_CD_EF_pool		1	default primary	EF15	SingleTag	dm5	BC Kit Module 1-16	"12"
AB_CD_EF_pool		1	default primary	AB_A1M1	SingleTag	hg18	BC Kit Module 1-16	"3"
AB_CD_EF_pool		1	default primary	AB_A1M2	SingleTag	hg18	BC Kit Module 1-16	"4"
AB_CD_EF_pool		1	default primary	AB_A1M1_input	SingleTag	hg18	BC Kit Module 1-16	"1"
AB_CD_EF_pool		1	default primary	AB_A1M2_input	SingleTag	hg18	BC Kit Module 1-16	"2"
"""       
        if filename is None:
            # mkstemp returns a tuple
            tmpfile = tempfile.mkstemp()
            filename = tmpfile[1]
        fp = open(filename,'w')
        fp.write(run_definition_text)
        fp.close()
        return filename

    def make_barcode_statistics_file(self,filename=None):
        """Create example barcode statistics file.

        If a name is explicitly specified then the file will be created
        with that name; otherwise a temporary file name will be generated.

        Returns the name for the barcode statistics file.
        """
        barcode_statistics_text = \
"""#? missing-barcode-reads=0
#? missing-F3-reads=0
##Library	Barcode	0 Mismatches	1 Mismatch	Total
AB_A1M1	3	32034098	3010512	35044610
AB_A1M1	Subtotals	32034098	3010512	35044610
EF14	11	33802784	2697225	36500009
EF14	Subtotals	33802784	2697225	36500009
CD_UV5	7	34132646	2304212	36436858
CD_UV5	Subtotals	34132646	2304212	36436858
EF12	9	35492369	2789254	38281623
EF12	Subtotals	35492369	2789254	38281623
EF13	10	30460845	2818591	33279436
EF13	Subtotals	30460845	2818591	33279436
EF15	12	36824658	2939962	39764620
EF15	Subtotals	36824658	2939962	39764620
AB_A1M2	4	35897351	2904080	38801431
AB_A1M2	Subtotals	35897351	2904080	38801431
EF11	8	24853173	2186475	27039648
EF11	Subtotals	24853173	2186475	27039648
CD_ST4	5	44673850	4675548	49349398
CD_ST4	Subtotals	44673850	4675548	49349398
CD_PQ5	6	40817315	4882499	45699814
CD_PQ5	Subtotals	40817315	4882499	45699814
AB_A1M1_input	2	33385249	2446268	35831517
AB_A1M1_input	Subtotals	33385249	2446268	35831517
AB_A1M2_input	1	27425404	2814422	30239826
AB_A1M2_input	Subtotals	27425404	2814422	30239826
unassigned	03020	98926	1021138	1120064
unassigned	12213	10872	611071	621943
unassigned	20131	9880	696765	706645
unassigned	31302	8180	654309	662489
unassigned	unresolved	NA	NA	8162042
unassigned	Subtotals	127858	2983283	11273183
All Beads	Totals	409927600	39452331	457541973
"""
        if filename is None:
            # mkstemp returns a tuple
            tmpfile = tempfile.mkstemp()
            filename = tmpfile[1]
        fp = open(filename,'w')
        fp.write(barcode_statistics_text)
        fp.close()
        return filename

    def make_solid_dir(self,solid_run_name):
        """Create a mock SOLiD run directory structure.

        Creates a temporary directory and builds a mock SOLiD run directory
        called 'solid_run_name' inside that.
        
        Returns the full path to the mock SOLiD run directory.
        """
        
        # Put everything in a temporary directory
        top_level = tempfile.mkdtemp()
        # Top-level
        dirname = os.path.join(top_level,solid_run_name)
        os.mkdir(dirname)
        self.make_run_definition_file(dirname+'/'+solid_run_name+'_run_definition.txt')
        #
        # Subdirectories:
        #
        ### solidXXX/plots
        os.makedirs(dirname+'/plots')
        #
        ### solidXXX/AB_CD_EF_pool
        os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1')
        os.symlink('results.F1B1',dirname+'/AB_CD_EF_pool/results')
        #
        ### solidXXX/AB_CD_EF_pool/results.F1B1/
        os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries')
        os.makedirs(dirname+
                    '/AB_CD_EF_pool/results.F1B1/primary.20131234567890')
        os.makedirs(dirname+
                    '/AB_CD_EF_pool/results.F1B1/primary.20132345678901')
        #
        ## solidXXX/AB_CD_EF_pool/results.F1B1/libraries/
        self.make_barcode_statistics_file(
            dirname+
            '/AB_CD_EF_pool/results.F1B1/libraries/'+
            'BarcodeStatistics.20130123456789012.txt')
        for d in ('CD_UV5','CD_PQ5','CD_ST4',
                  'EF11','EF12','EF13','EF14','EF15',
                  'AB_A1M1','AB_A1M2','AB_A1M1_input','AB_A1M2_input'):
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d)
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/intermediate')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201301234567890')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201301234567890/reads')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201301234567890/reports')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reads')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reject')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reports')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/secondary.F3.20130012345678')
            os.makedirs(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/temp')
            #
            # solidXXX/AB_CD_EF_pool/results.F1B1/libraries/X/primary.x/reads/
            self.make_csfasta(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                              '/primary.201312345678901/reads/'+
                              solid_run_name+'_AB_CD_EF_pool_F3_'+d+'.csfasta')
            self.make_qual(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                           '/primary.201312345678901/reads/'+
                           solid_run_name+'_AB_CD_EF_pool_F3_QV_'+d+'.qual')
            self.touch(dirname+'/AB_CD_EF_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reads/'+
                       solid_run_name+'_AB_CD_EF_pool_F3.stats')
        # Return the temporary directory with the mock SOLiD run 
        return dirname

    def make_run_definition_file_paired_end(self,filename=None):
        """Create example run definition file for paired-end run.

        If a name is explicitly specified then the file will be created
        with that name; otherwise a temporary file name will be generated.

        Returns the name for the run definition file.
        """
        run_definition_text = \
"""version	userId	runType	isMultiplexing	runName	runDesc	mask	protocol
v1.3	lab_user	PAIRED-END	TRUE	solid123_20130426_PE_BC		1_spot_mask_sf	SOLiD4 Multiplex
primerSet	baseLength
BC	10
F5-BC	35
F3	50
sampleName	sampleDesc	spotAssignments	primarySetting	library	application	secondaryAnalysis	multiplexingSeries	barcodes
AB_CD_pool		1	default primary	AB_SEQ26	SingleTag	sacCer2	BC Kit Module 1-96	"17"
AB_CD_pool		1	default primary	AB_SEQ27	SingleTag	sacCer2	BC Kit Module 1-96	"18"
AB_CD_pool		1	default primary	AB_SEQ28	SingleTag	sacCer2	BC Kit Module 1-96	"19"
AB_CD_pool		1	default primary	AB_SEQ29	SingleTag	sacCer2	BC Kit Module 1-96	"20"
AB_CD_pool		1	default primary	AB_SEQ30	SingleTag	sacCer2	BC Kit Module 1-96	"21"
AB_CD_pool		1	default primary	AB_SEQ31	SingleTag	sacCer2	BC Kit Module 1-96	"22"
AB_CD_pool		1	default primary	AB_SEQ32	SingleTag	sacCer2	BC Kit Module 1-96	"23"
AB_CD_pool		1	default primary	AB_SEQ33	SingleTag	sacCer2	BC Kit Module 1-96	"24"
AB_CD_pool		1	default primary	CD_SP6033	SingleTag	none	BC Kit Module 1-96	"1"
AB_CD_pool		1	default primary	CD_SP6257	SingleTag	none	BC Kit Module 1-96	"3"
AB_CD_pool		1	default primary	CD_SP6261	SingleTag	none	BC Kit Module 1-96	"2"
"""   
        if filename is None:
            # mkstemp returns a tuple
            tmpfile = tempfile.mkstemp()
            filename = tmpfile[1]
        fp = open(filename,'w')
        fp.write(run_definition_text)
        fp.close()
        return filename

    def make_barcode_statistics_file_paired_end(self,filename=None):
        """Create example barcode statistics file for paired-end run.

        If a name is explicitly specified then the file will be created
        with that name; otherwise a temporary file name will be generated.

        Returns the name for the barcode statistics file.
        """
        barcode_statistics_text = \
"""#? missing-barcode-reads=0
#? missing-F3-reads=0
##Library	Barcode	0 Mismatches	1 Mismatch	Total
AB_SEQ26	19	32034098	3010512	35044610
AB_SEQ26	Subtotals	32034098	3010512	35044610
AB_SEQ27	18	33802784	2697225	36500009
AB_SEQ27	Subtotals	33802784	2697225	36500009
AB_SEQ28	21	34132646	2304212	36436858
AB_SEQ28	Subtotals	34132646	2304212	36436858
AB_SEQ29	20	35492369	2789254	38281623
AB_SEQ29	Subtotals	35492369	2789254	38281623
AB_SEQ30	22	30460845	2818591	33279436
AB_SEQ30	Subtotals	30460845	2818591	33279436
AB_SEQ31	3	36824658	2939962	39764620
AB_SEQ31	Subtotals	36824658	2939962	39764620
AB_SEQ32	1	35897351	2904080	38801431
AB_SEQ32	Subtotals	35897351	2904080	38801431
AB_SEQ33	2	24853173	2186475	27039648
AB_SEQ33	Subtotals	24853173	2186475	27039648
CD_SP6033	23	44673850	4675548	49349398
CD_SP6033	Subtotals	44673850	4675548	49349398
CD_SP6257	17	40817315	4882499	45699814
CD_SP6257	Subtotals	40817315	4882499	45699814
CD_SP6261	24	33385249	2446268	35831517
CD_SP6261	Subtotals	33385249	2446268	35831517
unassigned	03020	98926	1021138	1120064
unassigned	12213	10872	611071	621943
unassigned	20131	9880	696765	706645
unassigned	31302	8180	654309	662489
unassigned	unresolved	NA	NA	8162042
unassigned	Subtotals	127858	2983283	11273183
All Beads	Totals	409927600	39452331	457541973
"""
        if filename is None:
            # mkstemp returns a tuple
            tmpfile = tempfile.mkstemp()
            filename = tmpfile[1]
        fp = open(filename,'w')
        fp.write(barcode_statistics_text)
        fp.close()
        return filename

    def make_solid_dir_paired_end(self,solid_run_name):
        """Create a mock SOLiD run directory structure for paired-end run.

        Creates a temporary directory and builds a mock SOLiD run directory
        called 'solid_run_name' inside that.
        
        Returns the full path to the mock SOLiD run directory.
        """
        
        # Put everything in a temporary directory
        top_level = tempfile.mkdtemp()
        # Top-level
        dirname = os.path.join(top_level,solid_run_name)
        os.mkdir(dirname)
        self.make_run_definition_file_paired_end(
            dirname+'/'+solid_run_name+'_run_definition.txt')
        #
        # Subdirectories:
        #
        ### solidXXX/plots
        os.makedirs(dirname+'/plots')
        #
        ### solidXXX/AB_CD_pool
        os.makedirs(dirname+'/AB_CD_pool/results.F1B1')
        os.symlink('results.F1B1',dirname+'/AB_CD_pool/results')
        #
        ### solidXXX/AB_CD_pool/results.F1B1/
        os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries')
        os.makedirs(dirname+
                    '/AB_CD_pool/results.F1B1/primary.20131234567890')
        os.makedirs(dirname+
                    '/AB_CD_pool/results.F1B1/primary.20132345678901')
        #
        ## solidXXX/AB_CD_pool/results.F1B1/libraries/
        self.make_barcode_statistics_file_paired_end(
            dirname+
            '/AB_CD_pool/results.F1B1/libraries/'+
            'BarcodeStatistics.20130123456789012.txt')
        for d in ('AB_SEQ26','AB_SEQ27','AB_SEQ28','AB_SEQ29',
                  'AB_SEQ30','AB_SEQ31','AB_SEQ32','AB_SEQ33',
                  'CD_SP6033','CD_SP6257','CD_SP6261'):
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d)
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/intermediate')
            # Primary with no rejects (shouldn't be used)
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201301234567890')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201301234567890/reads')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201301234567890/reports')
            # Primary with reads, rejects and reports for F5 reads
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reads')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reject')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reports')
            # Primary with reads, rejects and reports for forward reads
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201322345678901')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201322345678901/reads')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201322345678901/reject')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201322345678901/reports')
            # Secondaries (shouldn't be used)
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/secondary.F5-BC.20130012345678')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/secondary.F5-BC.20130123456789')
            os.makedirs(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/temp')
            #
            # Populate F5 read dirs
            # solidXXX/AB_CD_pool/results.F1B1/libraries/X/primary.x/reads/
            self.make_csfasta(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                              '/primary.201312345678901/reads/'+
                              solid_run_name+'_AB_CD_pool_F5-BC_'+d+'.csfasta')
            self.make_qual(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                           '/primary.201312345678901/reads/'+
                           solid_run_name+'_AB_CD_pool_F5-BC_QV_'+d+'.qual')
            self.touch(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201312345678901/reads/'+
                       solid_run_name+'_AB_CD_pool_F5-BC.stats')
            #
            # Populate forward read dirs
            # solidXXX/AB_CD_pool/results.F1B1/libraries/X/primary.x/reads/
            self.make_csfasta(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                              '/primary.201322345678901/reads/'+
                              solid_run_name+'_AB_CD_pool_F3_'+d+'.csfasta')
            self.make_qual(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                           '/primary.201322345678901/reads/'+
                           solid_run_name+'_AB_CD_pool_F3_QV_'+d+'.qual')
            self.touch(dirname+'/AB_CD_pool/results.F1B1/libraries/'+d+
                        '/primary.201322345678901/reads/'+
                       solid_run_name+'_AB_CD_pool_F3.stats')
        # Return the temporary directory with the mock SOLiD run 
        return dirname

    def touch(self,filename):
        """Make a new (empty) file
        """
        if not os.path.exists(filename):
            open(filename, 'w').close()

    def make_csfasta(self,filename):
        """Make a mock csfasta file
        """
        fp = open(filename,'w')
        fp.write(">1_14_622_F3\nT221.0033033232320030021103233332300123110201010031\n>1_14_1098_F3\nT033.3010033212202122212231302012120001123133212220\n")
        fp.close()

    def make_qual(self,filename):
        """Make a mock qual file
        """
        fp = open(filename,'w')
        fp.write(">1_14_622_F3\n33 33 32 -1 29 32 32 11 33 29 26 26 28 32 4 18 24 4 33 23 28 28 28 28 29 15 30 12 30 4 24 32 17 27 8 18 30 7 19 9 18 21 4 32 4 19 5 10 24 4 \n>1_14_1098_F3\n33 33 33 -1 33 33 33 30 33 31 28 31 30 31 29 32 33 31 33 33 27 32 24 33 31 32 31 30 32 24 32 24 31 33 31 33 24 33 10 22 30 25 4 17 22 27 22 28 31 19 \n")
        fp.close()

class TestSolidRunInfo(unittest.TestCase):
    """Unit tests for SolidRunInfo class.
    """
    def test_flow_cell_one(self):
        instrument = 'solid0123'
        datestamp  = '20130426'
        fragment   = 'FRAG'
        barcode    = 'BC'
        run_name   = instrument+'_'+datestamp+'_'+fragment+'_'+barcode
        info = SolidRunInfo(run_name)
        self.assertEqual(run_name,info.name)
        self.assertEqual(run_name,info.id)
        self.assertEqual(instrument,info.instrument)
        self.assertEqual(datestamp,info.datestamp)
        self.assertEqual(1,info.flow_cell)
        self.assertTrue(info.is_fragment_library)
        self.assertTrue(info.is_barcoded_sample)
        self.assertEqual('26/04/13',info.date)
        self.assertEqual(str(info),run_name)

    def test_flow_cell_two(self):
        instrument = 'solid0123'
        datestamp  = '20130426'
        fragment   = 'FRAG'
        barcode    =  'BC'
        run_id     =  instrument+'_'+datestamp+'_'+fragment+'_'+barcode
        run_name   =  run_id+'_2'
        info = SolidRunInfo(run_name)
        self.assertEqual(run_name,info.name)
        self.assertEqual(run_id,info.id)
        self.assertEqual(instrument,info.instrument)
        self.assertEqual(datestamp,info.datestamp)
        self.assertEqual(2,info.flow_cell)
        self.assertTrue(info.is_fragment_library)
        self.assertTrue(info.is_barcoded_sample)
        self.assertEqual('26/04/13',info.date)
        self.assertEqual(str(info),run_name)

class TestSolidLibrary(unittest.TestCase):
    """Unit tests for SolidLibrary class.
    """
    def test_solid_library(self):
        sample_name = 'PJB_pool'
        library_name = 'PJB_NY17'
        sample = SolidSample(sample_name)
        library = SolidLibrary(library_name,sample)
        self.assertEqual(library_name,library.name)
        self.assertEqual('PJB',library.initials)
        self.assertEqual('PJB_NY',library.prefix)
        self.assertEqual('17',library.index_as_string)
        self.assertEqual(17,library.index)
        self.assertFalse(library.is_barcoded)
        self.assertEqual(None,library.csfasta)
        self.assertEqual(None,library.qual)
        self.assertEqual(sample,library.parent_sample)
        self.assertEqual(library_name,str(library))

    def test_solid_library_with_files(self):
        sample_name = 'PJB_pool'
        library_name = 'PJB_NY17'
        sample = SolidSample(sample_name)
        library = SolidLibrary(library_name,sample)
        library.csfasta = '/path/to/solid_PJB.csfasta'
        library.qual = '/path/to/solid_PJB_QV.qual'
        self.assertEqual('/path/to/solid_PJB.csfasta',library.csfasta)
        self.assertEqual('/path/to/solid_PJB_QV.qual',library.qual)
        self.assertEqual(library_name,str(library))

    def test_solid_library_with_no_sample(self):
        library_name = 'PJB_NY17'
        library = SolidLibrary(library_name)
        self.assertEqual(None,library.parent_sample)

    def test_solid_library_indexes(self):
        # No index
        library_name = 'PJB_NY'
        library = SolidLibrary(library_name)
        self.assertEqual('',library.index_as_string)
        self.assertEqual(None,library.index)
        # Leading zero
        library_name = 'PJB_NY_01'
        library = SolidLibrary(library_name)
        self.assertEqual('01',library.index_as_string)
        self.assertEqual(1,library.index)
        # Trailing zero
        library_name = 'PJB_NY_10'
        library = SolidLibrary(library_name)
        self.assertEqual('10',library.index_as_string)
        self.assertEqual(10,library.index)

class TestSolidSample(unittest.TestCase):
    """Unit tests for SolidSample class.
    """
    def test_solid_sample(self):
        sample_name = 'PJB_pool'
        sample = SolidSample(sample_name)
        self.assertEqual(sample_name,sample.name)
        self.assertEqual(None,sample.parent_run)
        self.assertEqual(None,sample.barcode_stats)
        self.assertEqual(None,sample.libraries_dir)
        self.assertEqual(0,len(sample.libraries))
        self.assertEqual(0,len(sample.projects))

    def test_solid_sample_add_library(self):
        sample_name = 'PJB_pool'
        sample = SolidSample(sample_name)
        self.assertEqual(0,len(sample.libraries))
        # Add first library
        library = sample.addLibrary('PJB_NY_17')
        self.assertTrue(isinstance(library,SolidLibrary))
        self.assertEqual(1,len(sample.libraries))
        self.assertEqual(library,sample.getLibrary('PJB_NY_17'))
        # Add second library
        library2 = sample.addLibrary('PJB_NY_18')
        self.assertTrue(isinstance(library2,SolidLibrary))
        self.assertEqual(2,len(sample.libraries))
        self.assertEqual(library2,sample.getLibrary('PJB_NY_18'))
        # Add same library again
        self.assertEqual(library2,sample.addLibrary('PJB_NY_18'))
        self.assertEqual(2,len(sample.libraries))
        # Fetch non-existent library
        self.assertEqual(None,sample.getLibrary('PJB_NY_19'))

    def test_solid_sample_get_project(self):
        sample_name = 'PJB_pool'
        sample = SolidSample(sample_name)
        self.assertEqual(0,len(sample.projects))
        # Add libraries
        library = sample.addLibrary('PJB_NY_17')
        library = sample.addLibrary('PJB_NY_18')
        # Fetch project
        self.assertEqual(1,len(sample.projects))
        project = sample.getProject('PJB')
        self.assertTrue(isinstance(project,SolidProject))
        # Fetch non-existant project
        self.assertEqual(None,sample.getProject('BJP'))

class TestSolidProject(unittest.TestCase):
    """Unit tests for SolidProject class
    """

    def setUp(self):
        # Construct a sample object and populate
        # with libraries
        self.library_names = ['PJB_NY_17',
                              'PJB_NY_18',
                              'PJB_NY_19']
        self.sample = SolidSample('PJB_pool')
        for name in self.library_names:
            self.sample.addLibrary(name)
        self.project = self.sample.projects[0]

    def test_libraries(self):
        """Check that library information is correct
        """
        # Correct number of libraries
        self.assertEqual(len(self.library_names),len(self.project.libraries))
        # Check each library
        for i in range(len(self.library_names)):
            self.assertTrue(isinstance(self.project.libraries[i],SolidLibrary))
            self.assertEqual(self.library_names[i],self.project.libraries[i].name)

    def test_get_sample(self):
        """Test retrieval of parent sample
        """
        # Check for project with parent sample defined
        self.assertEqual(self.sample,self.project.getSample())
        # Check for project with no parent sample
        self.assertEqual(None,SolidProject('No_sample').getSample())

    def test_get_run(self):
        """Test retrieval of parent run
        """
        self.assertEqual(None,self.project.getRun())

    def test_is_barcoded(self):
        """Test check on whether all libraries in the project are barcoded
        """
        # Check test project
        self.assertFalse(self.project.isBarcoded())
        # Alter libraries in project so all have barcode flag set
        for lib in self.project.libraries:
            lib.is_barcoded = True
        self.assertTrue(self.project.isBarcoded())
        # Check with empty project (i.e. no libraries)
        self.assertFalse(SolidProject('No_libraries').isBarcoded())

    def test_get_library_name_pattern(self):
        """Test generation of pattern for library names in the project
        """
        self.assertEqual('PJB_NY_1*',self.project.getLibraryNamePattern())

    def test_get_project_name(self):
        """Test the name assigned to the project
        """
        self.assertEqual('PJB_pool',self.project.getProjectName())

    def test_pretty_print_libraries(self):
        """Test wrapper to pretty_print_libraries
        """
        self.assertEqual('PJB_NY_17-19',self.project.prettyPrintLibraries())

class TestSolidRunDefinition(unittest.TestCase):
    """Unit tests for SolidRunDefinition class.
    """

    def setUp(self):
        self.tmp_defn_file = TestUtils().make_run_definition_file()
        self.run_defn = SolidRunDefinition(self.tmp_defn_file)

    def tearDown(self):
        os.remove(self.tmp_defn_file)

    def test_solid_run_definition(self):
        self.assertTrue(isinstance(self.run_defn,SolidRunDefinition))
        self.assertTrue(self.run_defn)

    def test_nsamples(self):
        self.assertEqual(12,self.run_defn.nSamples())

    def test_attributes(self):
        self.assertEqual(self.run_defn.version,'v0.0')
        self.assertEqual(self.run_defn.userId,'user')
        self.assertEqual(self.run_defn.runType,'FRAGMENT')
        self.assertEqual(self.run_defn.isMultiplexing,'TRUE')
        self.assertEqual(self.run_defn.runName,'solid0123_20130426_FRAG_BC_2')
        self.assertEqual(self.run_defn.runDesc,'')
        self.assertEqual(self.run_defn.mask,'1_spot_mask_sf')
        self.assertEqual(self.run_defn.protocol,'SOLiD4 Multiplex')

    def test_fields(self):
        self.assertEqual(['sampleName',
                          'sampleDesc',
                          'spotAssignments',
                          'primarySetting',
                          'library',
                          'application',
                          'secondaryAnalysis',
                          'multiplexingSeries',
                          'barcodes'],
                         self.run_defn.fields())

    def test_get_data_item(self):
        # Check first line
        self.assertEqual('AB_CD_EF_pool',
                         self.run_defn.getDataItem('sampleName',0))
        self.assertEqual('CD_UV5',self.
                         run_defn.getDataItem('library',0))
        self.assertEqual('mm9',
                         self.run_defn.getDataItem('secondaryAnalysis',0))
        # Check line in middle
        self.assertEqual('AB_CD_EF_pool',
                         self.run_defn.getDataItem('sampleName',4))
        self.assertEqual('EF12',
                         self.run_defn.getDataItem('library',4))
        self.assertEqual('dm5',
                         self.run_defn.getDataItem('secondaryAnalysis',4))
        # Check non-existent line
        self.assertRaises(IndexError,
                          self.run_defn.getDataItem,'sampleName',12)
        # Check non-existent field
        self.assertEqual(None,
                         self.run_defn.getDataItem('tertiaryAnalysis',0))
        self.assertEqual(None,
                         self.run_defn.getDataItem('tertiaryAnalysis',12))

    def test_nonexistent_run_definition_file(self):
        """Check failure mode when run definition file is missing
        """
        run_defn = SolidRunDefinition("i_dont_exist")
        self.assertFalse(run_defn)

class TestSolidBarcodeStatistics(unittest.TestCase):
    """Unit tests for SolidBarcodeStatistics class.
    """

    def setUp(self):
        self.tmp_stats_file = TestUtils().make_barcode_statistics_file()
        self.stats = SolidBarcodeStatistics(self.tmp_stats_file)

    def tearDown(self):
        os.remove(self.tmp_stats_file)

    def test_solid_barcode_statistics(self):
        self.assertTrue(isinstance(self.stats,SolidBarcodeStatistics))
        self.assertTrue(self.stats)

    def test_nRows(self):
        self.assertEqual(31,self.stats.nRows())

    def test_header(self):
        self.assertEqual(['Library',
                          'Barcode',
                          '0 Mismatches',
                          '1 Mismatch',
                          'Total'],
                         self.stats.header)

    def test_get_data_by_name(self):
        # Check "All Beads" line
        self.assertEqual(['All Beads',
                          'Totals',
                          '409927600',
                          '39452331',
                          '457541973'],
                         self.stats.getDataByName('All Beads'))
        # Check non-existent line
        self.assertEqual(None,self.stats.getDataByName('All beads'))

    def test_total_reads(self):
        """Check total number of reads
        """
        # Total number for this example is 446268790
        self.assertEqual(446268790,self.stats.totalReads())

    def test_nonexistent_barcode_stats_file(self):
        """Check failure mode when barcode statistics file is missing
        """
        stats = SolidBarcodeStatistics("i_dont_exist")
        self.assertFalse(stats)

class TestSolidRun(unittest.TestCase):
    """Unit tests for SolidRun class.
    """
    def setUp(self):
        # Set up a mock SOLiD directory structure
        self.solid_test_dir = \
            TestUtils().make_solid_dir('solid0123_20130426_FRAG_BC')
        # Create a SolidRun object for tests
        self.solid_run = SolidRun(self.solid_test_dir)

    def tearDown(self):
        shutil.rmtree(self.solid_test_dir)

    def test_solid_run(self):
        self.assertTrue(self.solid_run)

    def test_libraries_are_assigned(self):
        for sample in self.solid_run.samples:
            for library in sample.libraries:
                # Check names were assigned to data files
                self.assertNotEqual(None,library.csfasta)
                self.assertTrue(os.path.isfile(library.csfasta))
                self.assertNotEqual(None,library.qual)
                self.assertTrue(os.path.isfile(library.qual))
                # F5 reads should not be assigned
                self.assertEqual(None,library.csfasta_f5)
                self.assertEqual(None,library.qual_f5)

    def test_library_files_in_same_location(self):
        for sample in self.solid_run.samples:
            for library in sample.libraries:
                # Check they're in the same location as each other
                self.assertEqual(os.path.dirname(library.csfasta),
                                 os.path.dirname(library.qual))

    def test_library_parent_dir_has_reject(self):
        for sample in self.solid_run.samples:
            for library in sample.libraries:
                # Check that the parent dir also has "reject" dir
                self.assertTrue(os.path.isdir(
                        os.path.join(os.path.dirname(library.csfasta),
                                     '..','reject')))

    def test_fetch_libraries(self):
        """Retrieve libraries based on sample and library names
        """
        # Defaults should retrieve everything
        libraries = self.solid_run.fetchLibraries()
        self.assertEqual(len(libraries),12)
        for lib in libraries:
            self.assertEqual(libraries.count(lib),1)
        # "Bad" sample name shouldn't retrieve anything
        libraries = self.solid_run.fetchLibraries(sample_name='XY_PQ_VW_pool',library_name='*')
        self.assertEqual(len(libraries),0)
        # Specify exact sample and library names
        libraries = self.solid_run.fetchLibraries(sample_name='AB_CD_EF_pool',library_name='AB_A1M1')
        self.assertEqual(len(libraries),1)
        self.assertEqual(libraries[0].name,'AB_A1M1')
        # Specify wildcard library name
        libraries = self.solid_run.fetchLibraries(sample_name='AB_CD_EF_pool',library_name='AB_*')
        self.assertEqual(len(libraries),4)
        for lib in libraries:
            self.assertTrue(str(lib.name).startswith('AB_'))
            self.assertEqual(libraries.count(lib),1)
        # Specify wildcard sample and library name
        libraries = self.solid_run.fetchLibraries(sample_name='*',library_name='AB_*')
        self.assertEqual(len(libraries),4)
        for lib in libraries:
            self.assertTrue(str(lib.name).startswith('AB_'))
            self.assertEqual(libraries.count(lib),1)

    def test_slide_layout(self):
        """Check slide layout information
        """
        self.assertEqual(self.solid_run.slideLayout(),"Whole slide")

    def test_nonexistent_solid_run_dir(self):
        """Check failure mode when SOLiD run directory is missing
        """
        solid_run = SolidRun("/i/dont/exist/solid0123_20131013_FRAG_BC")
        self.assertFalse(solid_run)

class TestSolidRunPairedEnd(unittest.TestCase):
    """Unit tests for SolidRun class for paired-end run data.
    """
    def setUp(self):
        # Set up a mock SOLiD directory structure
        self.solid_test_dir = \
            TestUtils().make_solid_dir_paired_end('solid0123_20130426_PE_BC')
        # Create a SolidRun object for tests
        self.solid_run = SolidRun(self.solid_test_dir)

    def tearDown(self):
        shutil.rmtree(self.solid_test_dir)

    def test_solid_run(self):
        self.assertTrue(self.solid_run)

    def test_libraries_are_assigned(self):
        for sample in self.solid_run.samples:
            for library in sample.libraries:
                # Check names were assigned to data files
                self.assertNotEqual(None,library.csfasta)
                self.assertTrue(os.path.isfile(library.csfasta))
                self.assertNotEqual(None,library.qual)
                self.assertTrue(os.path.isfile(library.qual))
                # Check read names contain "_F3_"
                self.assertTrue(library.csfasta.rfind("_F3_") > -1)
                self.assertTrue(library.qual.rfind("_F3_") > -1)
                # F5 reads
                self.assertNotEqual(None,library.csfasta_f5)
                self.assertTrue(os.path.isfile(library.csfasta_f5))
                self.assertNotEqual(None,library.qual_f5)
                self.assertTrue(os.path.isfile(library.qual_f5))
                # Check F5 read names contain "_F5-BC_"
                self.assertTrue(library.csfasta_f5.rfind("_F5-BC_") > -1)
                self.assertTrue(library.qual_f5.rfind("_F5-BC_") > -1)

    def test_library_files_in_same_location(self):
        for sample in self.solid_run.samples:
            for library in sample.libraries:
                # Check they're in the same location as each other
                self.assertEqual(os.path.dirname(library.csfasta),
                                 os.path.dirname(library.qual))
                self.assertEqual(os.path.dirname(library.csfasta_f5),
                                 os.path.dirname(library.qual_f5))

    def test_library_parent_dir_has_reject(self):
        for sample in self.solid_run.samples:
            for library in sample.libraries:
                # Check that the parent dirs also has "reject" dir
                self.assertTrue(os.path.isdir(
                        os.path.join(os.path.dirname(library.csfasta),
                                     '..','reject')))
                self.assertTrue(os.path.isdir(
                        os.path.join(os.path.dirname(library.csfasta_f5),
                                     '..','reject')))

    def test_fetch_libraries(self):
        """Retrieve libraries based on sample and library names
        """
        # Defaults should retrieve everything
        libraries = self.solid_run.fetchLibraries()
        self.assertEqual(len(libraries),11)
        for lib in libraries:
            self.assertEqual(libraries.count(lib),1)
        # "Bad" sample name shouldn't retrieve anything
        libraries = self.solid_run.fetchLibraries(sample_name='XY_PQ_VW_pool',library_name='*')
        self.assertEqual(len(libraries),0)
        # Specify exact sample and library names
        libraries = self.solid_run.fetchLibraries(sample_name='AB_CD_pool',library_name='AB_SEQ26')
        self.assertEqual(len(libraries),1)
        self.assertEqual(libraries[0].name,'AB_SEQ26')
        # Specify wildcard library name
        libraries = self.solid_run.fetchLibraries(sample_name='AB_CD_pool',library_name='AB_*')
        self.assertEqual(len(libraries),8)
        for lib in libraries:
            self.assertTrue(str(lib.name).startswith('AB_'))
            self.assertEqual(libraries.count(lib),1)
        # Specify wildcard sample and library name
        libraries = self.solid_run.fetchLibraries(sample_name='*',library_name='AB_*')
        self.assertEqual(len(libraries),8)
        for lib in libraries:
            self.assertTrue(str(lib.name).startswith('AB_'))
            self.assertEqual(libraries.count(lib),1)

class TestFunctions(unittest.TestCase):
    """Unit tests for module functions.
    """
    def test_is_paired_end(self):
        # Test with non-paired end mock SOLiD directory
        self.solid_test_dir = TestUtils().make_solid_dir('solid0123_20130426_FRAG_BC')
        self.solid_run = SolidRun(self.solid_test_dir)
        self.assertFalse(is_paired_end(self.solid_run))
        shutil.rmtree(self.solid_test_dir)
        # Test with paired end mock SOLiD directory
        self.solid_test_dir = TestUtils().make_solid_dir_paired_end('solid0123_20130426_PE_BC')
        self.solid_run = SolidRun(self.solid_test_dir)
        self.assertTrue(is_paired_end(self.solid_run))
        shutil.rmtree(self.solid_test_dir)

    def test_extract_initials(self):
        self.assertEqual('DR',extract_initials('DR1'))
        self.assertEqual('EP',extract_initials('EP_NCYC2669'))
        self.assertEqual('CW',extract_initials('CW_TI'))

    def test_extract_prefix(self):
        self.assertEqual('LD_C',extract_prefix('LD_C1'))

    def test_extract_index(self):
        self.assertEqual('1',extract_index('LD_C1'))
        self.assertEqual('07',extract_index('DR07'))

    def test_slide_layout(self):
        """Check descriptions for slide layout based on number of samples
        """
        self.assertEqual("Whole slide",slide_layout(1))
        self.assertEqual("Quads",slide_layout(4))
        self.assertEqual("Octets",slide_layout(8))
        # Example of "bad" numbers of sample
        self.assertEqual(None,slide_layout(7))
        self.assertEqual(None,slide_layout("porkchops"))

    def test_pretty_print_libraries(self):
        """Test pretty printing of multiple library names
        """
        # Simple test
        libraries = []
        libraries.append(SolidLibrary('PB1'))
        libraries.append(SolidLibrary('PB2'))
        libraries.append(SolidLibrary('PB3'))
        libraries.append(SolidLibrary('PB4'))
        self.assertEqual("PB1-4",pretty_print_libraries(libraries))
        # Sequence with gaps
        libraries.append(SolidLibrary('PB7'))
        libraries.append(SolidLibrary('PB8'))
        self.assertEqual("PB1-4, PB7-8",pretty_print_libraries(libraries))
        # Sequence with leading zeroes
        libraries = []
        libraries.append(SolidLibrary('PB_01'))
        libraries.append(SolidLibrary('PB_02'))
        libraries.append(SolidLibrary('PB_03'))
        libraries.append(SolidLibrary('PB_04'))
        self.assertEqual("PB_01-04",pretty_print_libraries(libraries))
        # Not a sequence
        libraries = []
        libraries.append(SolidLibrary('PB_1ng'))
        libraries.append(SolidLibrary('PB_10ng'))
        libraries.append(SolidLibrary('PB_INPUT_1ng'))
        libraries.append(SolidLibrary('PB_INPUT_10ng'))
        self.assertEqual("PB_10ng, PB_1ng, PB_INPUT_10ng, PB_INPUT_1ng",
                         pretty_print_libraries(libraries))

#######################################################################
# Main program
#######################################################################

if __name__ == "__main__":
    # Turn off most logging output for tests
    logging.getLogger().setLevel(logging.CRITICAL)
    # Run tests
    unittest.main()

